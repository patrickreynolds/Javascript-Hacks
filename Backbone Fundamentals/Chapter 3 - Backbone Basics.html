<!-- Backbone Basics -->

<!-- 
In this section, you'll learn the essentials of Backbone's models, views, collections, events, and routers.

* Reference documentation for any questions.
-->

<!-- Backbone Boilerplate -->

<!DOCTYPE HTML>
<html>
	<head>
    <meta charset="UTF-8">
    <title>Backbone Boilerplate</title>
	</head>
	<body>

		<script src="http://code.jquery.com/jquery-latest.min.js" type="text/javascript"></script>
		<script src="http://documentcloud.github.com/underscore/underscore-min.js"></script>
		<script src="http://documentcloud.github.com/backbone/backbone-min.js"></script>
		<script>
		  // Your code goes here
		</script>
	</body>
</html>


<!-- Backbone Models -->

<script type="text/javascript">
// ==================================
// Model Example
var Todo = Backbone.Model.extend({});

// We can then create our own concrete instance of a (Todo) model
// with no values at all:
var todo1 = new Todo();

// Following logs: {}
console.log(JSON.stringify(todo1))

// or with some arbitrary data:
var todo2 = new Todo({
	title: 'Check the attributes of both model instances in the console.',
	completed: true
});

// Following logs: 
// "{"title":"Check the attributes of both model instances in the console.","completed":true}"
console.log(JSON.stringify(todo2));
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


// =====================================
// Initialization
// Initialize method is called hwen a new instance of amodel is created, such as a constructor.
var Todo = Backbone.Model.extend({
	intialize: function(){
		console.log('This model has been initialized.');
	}
});

var mTodo = new Todo();
// Logs: This model has been initialized.
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// =====================================
// Default values
var Todo = Backbone.Model.extend({
	// Default todo attribute values
	defaults: {
		title: '',
		completed: false
	}
});

// Now we can create our concrete instance of the model
// with default values as follows:
var todo1 = new Todo();

// Following logs: {"title":"","completed":false}
console.log(JSON.stringify(todo1));

// Or we could instantiate it with some of the attributes
var todo2 = new Todo({
	title: 'Check attributes of the logged models in the console.'
});

// Following logs: 
// {"title":"Check attributes of the logged models in the console.","completed":false}
console.log(JSON.stringify(todo2));

// Or override all of the default attributes:
var todo3 = new Todo({
	title: 'This todo is done, so take no action on this one.',
	completed: true
});

// Following logs: {"title":"This todo is done, so take no action on this one.","completed":true} 
console.log(JSON.stringify(todo3));
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



// =====================================
// Getters & Setters
// Model.get()
var Todo = Backbone.Model.extend({
	// Default todo attribute values
	defaults: {
		title: '',
		completed: false
	}
});

var todo1 = new Todo();
console.log(todo1.get('title')); 			// empty string
console.log(todo1.get('completed')); 	// false

var todo2 = new Todo ({
	title: "Retrieved with model's get() method.",
	completed: true
});
console.log(todo2.get('title')); 			// Retrieved with model's get() method.
console.log(todo2.get('completed')); 	// true


// Model.set()
// Model.set() sets a hash containing one or more attributes on the model. When any of these attributes alter the state of the model, a 'change' event is triggered on it. Change events for each attribute are also triggered and can be count (eg change:name, change:age)

var Todo = Backbone.Model.extend({
	// Default todo attribute values
	defaults: {
		title: '',
		completed: false
	}
});

// Setting the value of attributes via instantiation
var myTodo = new Todo({
	title: "Set through instantiation."
});
console.log('Todo title: ' + myTodo.get('title')); // Todo title: Set through instantiation.
console.log('Completed: ' + myTodo.get('completed')); // Completed: false

// Set single attribute value at a time through Model.set():
myTodo.set("title", "Title attribute set through Model.set().");
console.log('Todo title: ' + myTodo.get('title')); // Todo title: Title attribute set through Model.set().
console.log('Completed: ' + myTodo.get('completed')); // Completed: false

// Set map of attributes through Model.set():
myTodo.set({
	title: "Both attributes set through Model.set().",
	completed: true
});
console.log('Todo title: ' + myTodo.get('title')); // Todo title: Both attributes set through Model.set().
console.log('Completed: ' + myTodo.get('completed')); // Completed: true


// Direct access
// Models expose an .attributes attribute which represents an internal hash containing the state of that model. This is generally in the form of a JSON object similar to the model data you might find on the server but can take other forms.

// ** Setting values through the .attributes attribute on a model bypasses triggers bound to the model.

// Passing {silent:true} on change doesn't delay individual "change:attr" events. Instead they are silenced entirely:
var Person = new Backbone.Model();
Person.on("change:name", function() { console.log('Name changed'); })
Person.set({name: 'Andrew'})
// log entry: Name changed

Person.set({name: 'Jermey'}, {silent: true} );
// no log entry

console.log(Person.hasChanged("name"));
// true: change was recorded
console.log(Person.hasChanged(null));
// true: something (anything) has changed

// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


// =====================================
// Listening for changes to your model
// Model change events are added in the initializer method
var Todo = Backbone.Model.extend({
	// Default todo attribute values
	defaults: {
		title: '',
		completed: false
	},

	initialize: function() {
		console.log('This model has been initialized.');
		this.on('change', function(){
			console.log('An attribute in the Todo model has changed.');
		});
		this.on('change:title', function(){
			console.log('Name Changed');
		});
		this.on('change:completed', function(){
			console.log('Completed status changed.');
		});
	}
});

var myTodo = new Todo();

myTodo.set('title', 'The listener is triggered whenever an attribute value changes.');
console.log('Title has changed: ' + myTodo.get('title'));


myTodo.set('completed', true);
console.log('Completed has changed: ' + myTodo.get('completed'));

myTodo.set({
  title: 'Changing more than one attribute at the same time only triggers the listener once.',
  completed: true
});

// Above logs:
// This model has been initialized.
// Name Changed
// An attribute in the Todo model has changed.
// Title has changed: The listener is triggered whenever an attribute value changes.
// Completed status changed.
// An attribute in the Todo model has changed.
// Completed has changed: true
// Name Changed
// An attribute in the Todo model has changed.
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// =====================================
// Validation
// Backbone supports model validatoin through model.validate(), which allows checking the attribute values for a model prior to setting them. By default, validation accurs when the model is persisted using the save() method or when set() is called if {validate:true} is passed as an argument.
var Person = new Backbone.Model({name: 'Jermey'});

// Validate the model name
Person.validate = function(attrs){
	if (!attrs.name) {
		return 'I need your name';
	}
};

// Change the name
Person.set({name: 'Samuel'});
console.log(Person.get('name'));
// 'Samuel'

// Remove the name attribute, force validation
Person.unset('name', {validate: true} );
// false

// * More complex validation example
var Todo = Backbone.Model.extend({
	defaults: {
		completed: false
	},

	validate: function(attributes){
		if(attributes.title === undefined){
			return "Remember to set a title for your todo.";
		}
	},

	initialize: function(){
		console.log('This model has been initialized.');
		this.on('invalid', function(model, error){
			console.log(error);
		});
	}
});

var myTodo = new Todo();
myTodo.set('completed', true, {validate: true}); // logs: Remember to set a title for your todo.
console.log('completed: ' + myTodo.get('completed')); // completed: false
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</script>

<!-- Backbone Views -->
<script type="text/javascript">

// =====================================
// Creating New Views
// Views in Backbone don't contain the HTML markup for your application; they contain the logic behind the presentation of the model's data to the user.
// This is usually achieved using JavaScript templating such as Underscore, Mustache, jQuery-tmpl). A view's render() method can be bound to a model's change() event, enabling the view to instantly reflect model changes without requiring a full page refresh.

// Backbone View

var TodoView = Backbone.View.extend({

	tagname: 'li',

	// Cache the template function for a single item.
	todoTpl: _.template( "An example template" ),

	events: {
		'dblclick label': 'editl',
		'keypress .edit': 'updateOnEnter',
		'blur .edit': 'close'
	},

	initialize: function(options){
		// In Backbone 1.1.0 if you want to access passed option in
		// your view, you will need to save them as follows:
		this.options = options || {};
	},

	// Re-render the title of the todo item.
	render: function() {
		this.$el.html( this.todoTpl( this.model.toJSON() ) );
		this.input = this.$('.edit');
		return this;
	},

	edit: function() {
		// executed when todo label is double clicked
	},

	close: function() {
		// executed when todo loses focus
	},

	updateOnEnter: function( e ) {
		// executed on each keypress when in todo edit mode,
		// but we'll wait for enter to get in action
	}
});

var todoView = new TodoView();

// log reference to a DOM element that corresponds to the view instance
console.log( todoView.el ); // logs <li></li>
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// =====================================
// What is el?
// el is the central property of a view.
// el is a reference to a DOM element and all views must have one. Views can use el to compose their element's content and then insert it into the DOM all at once, wheich makes for faster rendering.

// There are two ways of associating a DOM element with a view
// 1. A new element can be created for the view and subsequently added to the DOM
// - When creating a new view, the developer can crate any combination of the following properties on the view: tagName, id, and className.
// - THe element is created as a div by default.

// 2. A reference can be made to an element which already exists in the page

// View Example
var TodosView = Backbone.View.extend({
	tagName: 'ul', // required, but defaults to 'div if not set'
	className: 'container', // optinoal, you can assign multiple classes to this property such as: 'container homepage first'
	id: 'todos' // optional
});

var todosView = new TodosView();

// The above code will render the following:
// <ul id="todos" class="container"></ul>

// If the element exists in the page, you can set el as a CSS selector that matces the element
el: '#footer'

// Alternatively, you can set el to an existing element when creating the view.
var todosView = new TodosView( {el: $('#footer')} );


// $el and $()
// view.$el == $( view.el )
// view.$( selector ) == $( view.el ).find( selector )
// In the TodosView example's render method, we see this.$el used to set the HTML of the element and this.$() used to find subelements of class 'edit'.


// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// setElement
// setElement is used when needed to apply an existing Backbone view to a different DOM element. This means both we need to override the this.el to both change the DOM reference and re-bind events to the new element.

// Example
var button1 = $('<button</button>');
var button2 = $('<button></button>');

// Define a new view
var View = Backbone.View.extend({
	events: {
		click: function( e ) {
			console.log( view.el === e.target );
		}
	}
});

// Create a new instance of the view, applying it to button1
var view = new View( {el: button1} );

view.setElement( button2 );

button1.trigger('click');
button2.trigger('click'); // returns true

// We can also provide raw markup to setElement
// as follows ( just to demonstrate it can be done ):
var view = new Backbone.View;
view.setElement('<p><a><b>test</b></a></p>');
console.log(view.$('a b').html()); // outputs "test"

// =====================================
// Understanding render()
// render() is an optional fucntion that defined the logic for rendering a template. We'll use Unddersocre's micro-templeting in these examples, but any templating framework would work.

// The render() method uses this template by passing it the toJSON() encoding of the attributes of the model associated with the view. The template returns its markup after using the model's title and completed flag to evaluate the expressions containing them. I then set this markup as the HTML content of the el DOM element using the $el property.

// A common Backbone convention is to return this at the end of render().
// THis is useful for a number of reasons
// 1. Making views easily reusable in other parents views.
// 2. creating a list of element without rendering and painting each of the individually. THis way they are only drawn once the entire list is populated.

// An example of the latter: ListView
var ListView = Backbone.View.extend({

  // Compile a template for this view. In this case '...'
  // is a placeholder for a template such as 
  // $("#list_template").html() 
  template: _.template(…),

  render: function() {
    this.$el.html(this.template(this.model.attributes));
    return this;
  }
});

// ItemView
var ItemView = Backbone.View.extend({
  events: {},
  render: function(){
    this.$el.html(this.template(this.model.attributes));
    return this;
  }
});

// * note the usage of return this; at the end of render
// This common pattern enables us to reuse the view as a sub-view. We can also use it to pre-render the view prior to rendering. 

var listView = Backbone.View.extend({
	render: function() {

		// Assume our model exposes the items we will
		// display in our list
		var items = this.model.get('items');

		// Loop through each of our items using the Underscore
		// _.each iterator
		_.each(items, function( item ){
			// Create a new instance of the ItemView, passing
			// it a specific model item
			var itemView = new ItemView( {model: item });
			// The itemView's DOM element is appended after it
			// has been rendered. Here, the 'return this' is helpful
			// as the itemView renders its model. Later, we ask for
			// its output ("el")
			this.$el.append( itemView.render().el );
		}, this );
	}
});
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// =====================================
// Backbone Events Hash
// Backbone events hash allow us to attach event listeners to either
// el-relative custom selectors, or directoy to el if no selector is provided.
// An event takes the form of a key-value pair:
// 'eventName selector': 'callbackFunction' and a number of DOM event-types are supported, including click, submit, mouseover, dblclick and more.

// Sample View
var TodoView = Backbone.View.extend({
	tagName: 'li',

	// with san events hash containing DOM events specific to an item:
	events: {
		'click .toggle': 'toggleCompleted',
		'dblclick label': 'edit',
		'keypress .edit': 'updateOnEnter',
		'cick .destroy': 'clear',
		'blur .edit': 'close'
	},
	...
});

// Callback breakdown
// In our TodoView example, the edit callback is invoked when the user double-clicks a label element within the el element, updateOnEnter is called for each keypress in an element with class 'edit', and close executes when an element with class 'edit' loses focus. Each of these callback functions can use this to refer to the TodoView object.

// Note that you can also bind methods yourself using _.bind(this.viewEvent, this), which is effectively what the value in each event's key-value pair is doing. Below we use _.bind to re-render our view when a model changes.

var TodoView = Backbone.View.extend({
	initialize: function() {
		this.model.bind('change', _.bind(this.render, this));
	}
});

// * note _.bind only works on one method at a time, but effectively binds a function to an object so that anytime the function is called the value of this will be the object. 

// _.bind also supports passing in arguments to the function in order to fill them in advance - a technique known as partial application.
// More info on partial application can be found here:
// http://benalman.com/news/2012/09/partial-application-in-javascript/
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</script>


<!-- Backbone Collection -->
<script type="text/javascript">
// Collections
// Collections are sets of Models and are created 
// by extending Backbone.Collection

// Normally, when creating a collection you'll also want to define a property specifying the type of model that your collectoin will contain, along with any instance properties required.

// The following is a TodoCollection that will contain our list
// of Todo models:
// =====================================
// TodoCollection
var Todo = Backbone.Model.extend({
	defaults: {
		title: '', 
		completed: false
	}
});

var TodosCollection = Backbone.Collection.extend({
	model: Todo
});

var myTodo = new Todo({title: 'Read the whole book', id: 2});

// pass array of models on collection instantiation

var todos = new TodosCollection([myTodo]);
console.log("Collectoin size: " + todos.length); // Collection size 1

// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// =====================================
// Adding and Removing Models
// The above example initialized the TodosCollection
// Models can be added and removed using the add() and remove() methods:
var Todo = Backbone.Model.extend({
  defaults: {
    title: '',
    completed: false
  }
});

var TodosCollection = Backbone.Collection.extend({
  model: Todo,
});

var a = new Todo({ title: 'Go to Jamaica.'});
var b = new Todo({ title: 'Go to China.'});
var c = new Todo({ title: 'Go to Disneyland.'});

var todos = new TodosCollection([a,b]);
console.log("Collection size: " + todos.length);
// Logs: Collection size: 2

todos.add(c);
console.log("Collection size: " + todos.length);
// Logs: Collection size: 3

todos.remove([a, b]);
console.log("Collection size: " + todos.length);
// Logs: Collection size: 1

todos.remove(c);
console.log("Collection size: " + todos.length);
// Logs: Collection size: 0

// Also note that when using add() on a collection, passing 
// {merge: true} causes duplicate models to have their attributes
// merged in to the existing models, instead of being ignored.

var items = new Backbone.Collection;
items.add([{ id : 1, name: "Dog" , age: 3}, { id : 2, name: "cat" , age: 2}]);
items.add([{ id : 1, name: "Bear" }], {merge: true });
items.add([{ id : 2, name: "lion" }]); // merge: false

console.log(JSON.stringify(items.toJSON()));
// [{"id":1,"name":"Bear","age":3},{"id":2,"name":"cat","age":2}]
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// =====================================
// Retrieving Models
// There are a few different ways to retrieve a model from a collection. The most straigh-forward is to use Collection.get() which accepts a single id:
var myTodo = new Todo({title: 'Read the whole book', id: 2});

// pass array of models on collection instantiation
var todos = new TodosCollection([myTodo]);

vat todo2 = todos.get(2);

// Models, as objects, are passed by reference
consoe.log(todo2 === myTodo); // true

// * Use id, cid, and idAttribute properties to uniquely identify models.

// Difference between id, cid, and idAttribute
/*
Each model in Backbone has an id, which is a unique identifier that is either an integer or string (e.g., a UUID). Models also have a cid (client id) which is automatically generated by Backbone when the model is created. Either identifier can be used to retrieve a model from a collection.

The main difference between them is that the cid is generated by Backbone; it is helpful when you don't have a true id - this may be the case if your model has yet to be saved to the server or you aren't saving it to a database.

The idAttribute is the identifying attribute name of the model returned from the server (i.e., the id in your database). This tells Backbone which data field from the server should be used to populate the id property (think of it as a mapper). By default, it assumes id, but this can be customized as needed. For instance, if your server sets a unique attribute on your model named "userId" then you would set idAttribute to "userId" in your model definition.

The value of a model's idAttribute should be set by the server when the model is saved. After this point you shouldn't need to set it manually, unless further control is required.

Internally, Backbone.Collection contains an array of models enumerated by their id property, if the model instances happen to have one. When collection.get(id) is called, this array is checked for existence of the model instance with the corresponding id.
*/

// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// =====================================
// Listening for events
// As collections represnt a group of items, we can listen for add and remove events which occur when models are added to or removed from a collection

var TodosCollection = new Backbone.Collection();

TodosCollection.on("add", function( todo ){
	console.log("I should " + todo.get("title") + ". Have I done it before? " + (todo.get('completed') ? 'Yeah!' : 'No.' ));
});

TodosCollection.add([
	{ title: 'go to Jamaica', completed: false },
	{ title: 'go to China', completed: false },
	//{ title: 'go to Disneyland', completed: true }
]);

// In addition, we'lre also able to bind to a chnage event to listen for changes to any of the models in the collection.
var TodosCollection = new Backbone.Collection();

// log a message if a model in the collection changes
TodosCollection.on("change:title", function(model) {
    console.log("Changed my mind! I should " + model.get('title'));
});

TodosCollection.add([
  { title: 'go to Jamaica.', completed: false, id: 3 },
]);

var myTodo = TodosCollection.get(3);

myTodo.set('title', 'go fishing');
// Logs: Changed my mind! I should go fishing

// jQuery-style event maps of the form obj.on({click: action}) can also be used.
var Todo = Backbone.Model.extend({
  defaults: {
    title: '',
    completed: false
  }
});

var myTodo = new Todo();
myTodo.set({title: 'Buy some cookies', completed: true});

myTodo.on({
   'change:title' : titleChanged,
   'change:completed' : stateChanged
});

function titleChanged(){
  console.log('The title was changed!');
}

function stateChanged(){
  console.log('The state was changed!');
}

myTodo.set({title: 'Get the groceries'});
// The title was changed! 

// Backbone events also support a once() mehtod, which ensures that a callback only fires one time when a notification arrives. It is similar to Done's once, or jQUery's one.
// Define an object with two counters
var TodoCounter = { counterA: 0, counterB: 0 };
// Mix in Backbone Events
_.extend(TodoCounter, Backbone.Events);

// Increment counterA, triggering an event
var incrA = function(){ 
  TodoCounter.counterA += 1; 
  TodoCounter.trigger('event'); 
};

// Increment counterB
var incrB = function(){ 
  TodoCounter.counterB += 1; 
};

// Use once rather than having to explicitly unbind
// our event listener
TodoCounter.once('event', incrA);
TodoCounter.once('event', incrB);

// Trigger the event once again
TodoCounter.trigger('event');

// Check out output
console.log(TodoCounter.counterA === 1); // true
console.log(TodoCounter.counterB === 1); // true

// If you need to sumply replace the entire content of the collection
// then Collection.reset() can be used:
var TodosCollection = new Backbone.Collection();

// we can listen for reset events
TodosCollection.on("reset", function() {
  console.log("Collection reset.");
});

TodosCollection.add([
  { title: 'go to Jamaica.', completed: false },
  { title: 'go to China.', completed: false },
  { title: 'go to Disneyland.', completed: true }
]);

console.log('Collection size: ' + TodosCollection.length); // Collection size: 3

TodosCollection.reset([
  { title: 'go to Cuba.', completed: false }
]);
// Above logs 'Collection reset.'

console.log('Collection size: ' + TodosCollection.length); // Collection size: 1


// Another useful tip is to use reset with no arguments to clear ot a collection completely. This is handy when dynamically loading a new page of results where you wna tot black out the current page of results.
myCollection.reset();
// * Collection.reset() doesn't fire any add or remove events.
// reset event is fired instead as shown in the previous example. The reason you might want to use this to perform super-optimized rendering in extreme cases where individual events are too expensive.

// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// =====================================
// Resetting/Refreshing Collections
// Rather than adding or removing models individually, you might want to
// update an entire collection at once.
// Collection.set() takes an array of models and performs the necessary add, remove, and change operations required to update the collection.

// Also note that listening to a reset event, the list of previous models is available in options.previousModels, for convenience.
var todo = new Backbone.Model();
var todos = new Backbone.Collection([todo])
.on('reset', function(todos, options) {
  console.log(options.previousModels);
  console.log([todo]);
  console.log(options.previousModels[0] === todo); // true
});
todos.reset([]);

// set() method is available for Collections can also be used for "smart"
// updating of sets of models.
// Define a model of type 'Beatle' with a 'job' attribute
var Beatle = Backbone.Model.extend({
  defaults: {
    job: 'musician'
  }
});

// Create models for each member of the Beatles
var john = new Beatle({ firstName: 'John', lastName: 'Lennon'});
var paul = new Beatle({ firstName: 'Paul', lastName: 'McCartney'});
var george = new Beatle({ firstName: 'George', lastName: 'Harrison'});
var ringo = new Beatle({ firstName: 'Ringo', lastName: 'Starr'});

// Create a collection using our models
var theBeatles = new Backbone.Collection([john, paul, george, ringo]);

// Create a separate model for Pete Best
var pete = new Beatle({ firstName: 'Pete', lastName: 'Best'});

// Update the collection
theBeatles.set([john, paul, george, pete]);

// Fires a `remove` event for 'Ringo', and an `add` event for 'Pete'.
// Updates any of John, Paul and Georges's attributes that may have
// changed over the years.

// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


// =====================================
// Underscore utility functions
// Backbone takes full advantage of its hard dependency on Underscore by making many of ts unilities directly available on collections:

// forEach: iterate over collections
var todos = new Backbone.Collection();
todos.add([
	{ title: 'go to Belgium.', completed: false },
  { title: 'go to China.', completed: false },
  { title: 'go to Austria..', completed: true }
]);

// iterate over models in the collection
todos.forEach(function( model ){
	console.log( model.get( 'title' ) );
});
// Above logs:
// go to Belgium.
// go to China.
// go to Austria.


// sortBy(): sort a collection on a specific attribute
// sorted collection
var sortedByAlphabet = todos.sortBy(function(){
	return todo.get('title').toLowerCase();
});

console.log(" - Now sorted: ");

sortedByAlphabet.forEach(function( model ){
	console.log( model.get( 'title' ) );
});
// Above logs:
// - Now sorted:
// go to Austria.
// go to Belgium.
// go to China.


// map(): iterate through a collection, mapping each value
// through a transformation function
var count = 1;
console.log(todos.map(function(model){
  return count++ + ". " + model.get('title');
}));
// Above logs:
//1. go to Belgium.
//2. go to China.
//3. go to Austria.

// min()/max(): retrieve item with the min or max vlaue of an attribute
todos.max( function( model ){
  return model.id;
}).id;

todos.min( function( model ){
  return model.id;
}).id;


// pluck(): extract a specific attribute
var captions = todos.pluck('caption');
// returns list of captions

// filter(): filter a collection
// Filter by an arrat of model IDs
var Todos = Backbone.Collection.extend({
  model: Todo,
  filterById: function(ids){
    return this.models.filter(
      function(c) { 
        return _.contains(ids, c.id); 
      })
  }
});


// indexOf(): return the index of a particular item within a collection
var people = new Backbone.Collection;

people.comparator = function(a, b) {
  return a.get('name') < b.get('name') ? -1 : 1;
};

var tom = new Backbone.Model({name: 'Tom'});
var rob = new Backbone.Model({name: 'Rob'});
var tim = new Backbone.Model({name: 'Tim'});

people.add(tom);
people.add(rob);
people.add(tim);

console.log(people.indexOf(rob) === 0); // true
console.log(people.indexOf(tim) === 1); // true
console.log(people.indexOf(tom) === 2); // true


// any(): confirm if any of the values in a collection pass an iterator truth test
todos.any(function(model){
  return model.id === 100;
});

// or
todos.some(function(model){
  return model.id === 100;
});


// size(); return the size of a collection
todos.size();
// equivalent to
todos.length;


// isEmpty(): determine whether a collection is empty
var isEmpty = todos.isEmpty();


// groupBy(): group a collection into groups of like items
var todos = new Backbone.Collection();

todos.add([
  { title: 'go to Belgium.', completed: false },
  { title: 'go to China.', completed: false },
  { title: 'go to Austria.', completed: true }
]);

// create groups of completed and incomplete models
var byCompleted = todos.groupBy('completed');
var completed = new Backbone.Collection(byCompleted[true]);
console.log(completed.pluck('title'));
// logs: ["go to Austria."]


// Underscore specific operations on objects are available as methods on Models


// pick(): extract a set of attributes from a model
var Todo = Backbone.Model.extend({
  defaults: {
    title: '',
    completed: false
  }
});

var todo = new Todo({title: 'go to Austria.'});
console.log(todo.pick('title'));
// logs {title: "go to Austria"}


// omit(): extract all attrivutes from a model except those listed
var todo = new Todo({title: 'go to Austria.'});
console.log(todo.omit('title'));
// logs {completed: false}


// keys() and values(): get lists of attribute names and values
var todo = new Todo({title: 'go to Austria.'});
console.log(todo.keys());
// logs: ["title", "completed"]

console.log(todo.values());
//logs: ["go to Austria.", false]


// pairs(): get list of attributes as [key, value] pairs
var todo = new Todo({title: 'go to Austria.'});
var pairs = todo.pairs();

console.log(pairs[0]);
// logs: ["title", "go to Austria."]
console.log(pairs[1]);
// logs: ["completed", false]


// invert(): create object in which the values are keys and the attributes are values
var todo = new Todo({title: 'go to Austria.'});
console.log(todo.invert());

// logs: {'go to Austria.': 'title', 'false': 'completed'}

// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// =====================================
// Chainable API
// Another bit of sugar in Backbone is its support for Underscores's
// chain() method.

// The inclusion of Underscore's chain() method enables you to chain calls
// to these methods on Collections.

// The chain() method return an object that has all of the Underscore 
// array operations attached as methods which return that object.

// The chainable API looks like this:
var collection = new Backbone.Collection([
  { name: 'Tim', age: 5 },
  { name: 'Ida', age: 26 },
  { name: 'Rob', age: 55 }
]);

var filteredNames = collection.chain() // start chain, returns wrapper around collection's models
  .filter(function(item) { return item.get('age') > 10; }) // returns wrapped array excluding Tim
  .map(function(item) { return item.get('name'); }) // returns wrapped array containing remaining names
  .value(); // terminates the chain and returns the resulting array

console.log(filteredNames); // logs: ['Ida', 'Rob']

// Another example
var collection = new Backbone.Collection();

collection
    .add({ name: 'John', age: 23 })
    .add({ name: 'Harry', age: 33 })
    .add({ name: 'Steve', age: 41 });

var names = collection.pluck('name');

console.log(names); // logs: ['John', 'Harry', 'Steve']

// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// =====================================
// Restful Persistence

// Fetching models from the server
// Collections.fetch() retrieves a set of models from the server in the form of a JSON array by sending an HTTP GET request to the URL specified by the collection's url property.

// When the data is received, a set() will be executed to update the collection.
var Todo = Backbone.Model.extend({
  defaults: {
    title: '',
    completed: false
  }
});

var TodosCollection = Backbone.Collection.extend({
  model: Todo,
  url: '/todos'
});

var todos = new TodosCollection();
todos.fetch(); // sends HTTP GET to /todos


// Saving models to the server
// While Backbone can retrieve an entire collection of models from the server at once, updates to models are performed individually using the model's save() method. When save() is called on a model that was fetched from the server, it constructs a URL by appending the model's id to the collection's URL and sends an HTTP PUT to the server. If the model is a new instance that was created in the browser (i.e., it doesn't have an id) then an HTTP POST is sent to the collection's URL. Collections.create() can be used to create a new model, add it to the collection, and send it to the server in a single method call.


var Todo = Backbone.Model.extend({
  defaults: {
    title: '',
    completed: false
  }
});

var TodosCollection = Backbone.Collection.extend({
  model: Todo,
  url: '/todos'
});

var todos = new TodosCollection();
todos.fetch();

var todo2 = todos.get(2);
todo2.set('title', 'go fishing');
todo2.save(); // sends HTTP PUT to /todos/2

todos.create({title: 'Try out code samples'}); // sends HTTP POST to /todos and adds to collection


// Deleting models from the server
// A model can be removed from the containing collection and the server by calling its destroy() method. Unlike Collection.remove() which only removes a model from a collection, Model.destroy() will also send an HTTP DELETE to the collection's URL.
var Todo = Backbone.Model.extend({
  defaults: {
    title: '',
    completed: false
  }
});

var TodosCollection = Backbone.Collection.extend({
  model: Todo,
  url: '/todos'
});

var todos = new TodosCollection();
todos.fetch();

var todo2 = todos.get(2);
todo2.destroy(); // sends HTTP DELETE to /todos/2 and removes from collection

// Calling destroy on a Model will return false if the model isNew:
var todo = new Backbone.Model();
console.log(todo.destroy());
// false


// Options

// Each RESTful API method accepts a variety of options. Most importantly, all methods accept success and error callbacks which can be used to customize the handling of server responses.

// Specifying the {patch: true} option to Model.save() will cause it to use HTTP PATCH to send only the changed attributes (i.e partial updates) to the server instead of the entire model i.e model.save(attrs, {patch: true}):

// Save partial using PATCH
model.clear().set({id: 1, a: 1, b: 2, c: 3, d: 4});
model.save();
model.save({b: 2, d: 4}, {patch: true});
console.log(this.syncArgs.method);
// 'patch'


// Similarly, passing the {reset: true} option to Collection.fetch() will result in the collection being updated using reset() rather than set().


// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</script>


<!-- Events -->
<script type="text/javascript">
// =====================================
// Events
// Events are a basic inverstion of control. Instead of having one function call another by name, the second function is registered as a handler to be called when a specific event occurs.

// The part of your application that has to know how to call the other part of your app has been inverted. This is the core thing that makes it possible for your business logic to not have to know about how your user interface works and is the most powerful things about the Backbone Events system

// Backbone.Events is mixed into the other Backbone "classes", including:
/*
- Backbone
- Backbone.Model
- Backbone.Collection
- Backbone.Router
- Backbone.History
- Backbone.View
*/
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// =====================================
// Events on(), off(), and trigger()
// We can mix this module into any object easily
var ourObject = {};

// Mixin
_.extend(ourObject, Backbone.Events);

// Add a custom event
ourObject.on('dance', function(msg){
	console.log('We triggered ' + msg + '!');
});

ourObject.trigger('dance', 'our event');


// The official Backbone.js documentation recommends namespacing event names using colons if you end up using quite a few of these on your page.
var ourObject = {};

// Mixin
_.extend(ourObject, Backbone.Events);

function dancing (msg) { console.log("We started " + msg); }

// Add namespaced custom events
ourObject.on("dance:tap", dancing);
ourObject.on("dance:break", dancing);

// Trigger the custom events
ourObject.trigger("dance:tap", "tap dancing. Yeah!");
ourObject.trigger("dance:break", "break dancing. Yeah!");

// This one triggers nothing as no listener listens for it
ourObject.trigger("dance", "break dancing. Yeah!");


// A special all event is made available in case you would like notifications for evey event that occurs on the object.
// Example: all events
var ourObject = {};

// Mixin
_.extend(ourObject, Backbone.Events);

function dancing (msg) { console.log("We started " + msg); }

ourObject.on("all", function(eventName){
  console.log("The name of the event passed was " + eventName);
});

// This time each event will be caught with a catch 'all' event listener
ourObject.trigger("dance:tap", "tap dancing. Yeah!");
ourObject.trigger("dance:break", "break dancing. Yeah!");
ourObject.trigger("dance", "break dancing. Yeah!");


// Off removes callback functions that were previously bound to an object. 
// Example: Removing/Unsubscribing events with off
var ourObject = {};

// Mixin
_.extend(ourObject, Backbone.Events);

function dancing (msg) { console.log("We " + msg); }

// Add namespaced custom events
ourObject.on("dance:tap", dancing);
ourObject.on("dance:break", dancing);

// Trigger the custom events. Each will be caught and acted upon.
ourObject.trigger("dance:tap", "started tap dancing. Yeah!");
ourObject.trigger("dance:break", "started break dancing. Yeah!");

// Removes event bound to the object
ourObject.off("dance:tap");

// Trigger the custom events again, but one is logged.
ourObject.trigger("dance:tap", "stopped tap dancing."); // won't be logged as it's not listened for
ourObject.trigger("dance:break", "break dancing. Yeah!");


// To remove all callbacks for the event we pass an event name to the off() method on the object the event is bound to. If we wish to remove a specific callback, we can pass that callback as the second parameter:
var ourObject = {};

// Mixin
_.extend(ourObject, Backbone.Events);

function dancing (msg) { console.log("We are dancing. " + msg); }
function jumping (msg) { console.log("We are jumping. " + msg); }

// Add two listeners to the same event
ourObject.on("move", dancing);
ourObject.on("move", jumping);

// Trigger the events. Both listeners are called.
ourObject.trigger("move", "Yeah!");

// Removes specified listener
ourObject.off("move", dancing);

// Trigger the events again. One listener left.
ourObject.trigger("move", "Yeah, jump, jump!");



// Finally, as we have seen in our previous examples, trigger triggers a callback for a speciried event.
var ourObject = {};

// Mixin
_.extend(ourObject, Backbone.Events);

function doAction (msg) { console.log("We are " + msg); }

// Add event listeners
ourObject.on("dance", doAction);
ourObject.on("jump", doAction);
ourObject.on("skip", doAction);

// Single event
ourObject.trigger("dance", 'just dancing.');

// Multiple events
ourObject.trigger("dance jump skip", 'very tired from so much action.');


// Trigger can pass multiple arguments to the callback function as well:
var ourObject = {};

// Mixin
_.extend(ourObject, Backbone.Events);

function doAction (action, duration) {
  console.log("We are " + action + ' for ' + duration ); 
}

// Add event listeners
ourObject.on("dance", doAction);
ourObject.on("jump", doAction);
ourObject.on("skip", doAction);

// Passing multiple arguments to single event
ourObject.trigger("dance", 'dancing', "5 minutes");

// Passing multiple arguments to multiple events
ourObject.trigger("dance jump skip", 'on fire', "15 minutes");

// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


// =====================================
// listenTo() and stopListening()
// While on() and off() add callbacks directly to an observed object, listenTo() tells an object to listen for events on another object, allowing the listener to keep track of the events for which it is listening.
var a = _.extend({}, Backbone.Events);
var b = _.extend({}, Backbone.Events);
var c = _.extend({}, Backbone.Events);

// add listeners to A for events on B and C
a.listenTo(b, 'anything', function(event){ console.log("anything happened"); });
a.listenTo(c, 'everything', function(event){ console.log("everything happened"); });

// trigger an event
b.trigger('anything'); // logs: anything happened

// stop listening
a.stopListening();

// A does not receive these events
b.trigger('anything');
c.trigger('everything');

// stopListening() can also be used to selectively stop listening based on the event, model, or callback handle.

// Learn more about ghost views here:
// http://lostechies.com/derickbailey/2011/09/15/zombies-run-managing-page-transitions-in-backbone-apps/

// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// =====================================
// Events and Views 
// Within a View, there are two types of events you can listen for:
// 1. DOM events
// DOM events can be bound to using the View's events property or using jQuery.on(). Within callbacks bound using the events property, this refers to the View object; whereas any callbacks bound directly using jQuery will have this set to the handling DOM element by jQuery. All DOM event callbacks are passed an event object by jQuery. See delegateEvents() in the Backbone documentation for additional details.

// 2. Events triggered using the Event API
// Event API events are bound as described in this section. If the event is bound using on() on the observed object, a context parameter can be passed as the third argument. If the event is bound using listenTo() then within the callback this refers to the listener. The arguments passed to Event API callbacks depends on the type of event. See the Catalog of Events in the Backbone documentation for details.

// Example
<div id="todo">
	<input type='checkbox' />
</div>


var View = Backbone.View.extend({

	el: '#todo',

	// bind to DOM event using events property
	events: {
		'click [type="checkbox"]': 'clicked',
	},

	initialize: function() {
		// bind to DOM event using jQuery
		this.$el.click(this.jqueryClicked);

		// bind to API event
		this.on('apiEvent', this.callback);
	},

	// 'this' is view
	clicked: function( event ) {
		console.log("events handler for " + this.el.outerHTML);
		this.trigger('apiEvent', event.type);
	},

	// 'this' is handling DOM element
	jqueryClicked: function(event) {
		console.log("jQuery handler for " + this.outerHTML);
	},

	callback: function(eventType) {
		console.log("event type was " + eventType);
	}

});

var view = new View();
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</script> 





<!-- Routers -->
<script type="text/javascript">

// =====================================


// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// =====================================


// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// =====================================


// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// =====================================


// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// =====================================


// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// =====================================


// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// =====================================


// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</script>


























